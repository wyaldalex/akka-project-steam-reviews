package dev.galre.josue.steamreviews
package controller

import akka.http.scaladsl.model.{ ContentTypes, StatusCodes }
import akka.http.scaladsl.server.Route
import akka.http.scaladsl.testkit.RouteTestTimeout
import akka.testkit.TestDuration
import akka.util.Timeout
import dev.galre.josue.steamreviews.generators.PayLoadGenerator._
import dev.galre.josue.steamreviews.repository.entity.GameActor.GameState
import dev.galre.josue.steamreviews.service.utils.Actors
import dev.galre.josue.steamreviews.service.utils.Actors.StateManagers
import dev.galre.josue.steamreviews.spec.RoutesSpec

import scala.concurrent.duration._
import scala.concurrent.ExecutionContext
import scala.util.Random

//Used to deserialize the entities
import de.heikoseeberger.akkahttpcirce.FailFastCirceSupport._
import io.circe.generic.auto._

class GameRouterTest extends RoutesSpec {

  Feature("A GameRouter Behavior") {

    implicit val timeout = Timeout(10.seconds)
//    val gameManagerActor: ActorRef = system.actorOf(GameManagerActor.props)
//    val stateManagers: StateManagers = StateManagers(
//      gameManagerActor, gameManagerActor, ActorRef.noSender,
//      ActorRef.noSender, ActorRef.noSender, ActorRef.noSender, ActorRef.noSender
//    )
    implicit def executionContext: ExecutionContext = system.dispatcher
    val stateManagers: StateManagers = Actors.init

    val routes: Route = GameRouter(stateManagers.Command.game, stateManagers.Query.game).routes

    Scenario("A client sends a request to create a new game") {

      implicit val timeout = RouteTestTimeout(10.seconds.dilated)
      Given("a valid Game Information and a POST request")
      val game = generateGameRequest()

      When("a request to create a new game is sent to the server")
      val autoGeneratedSteamGameId = Post("/games").withEntity(ContentTypes.`application/json`, game) ~!> routes ~> check {
        Then("will create a new game and will respond with the game id and a 201 created status")
        assert(status == StatusCodes.Created)
        processHeaderId(headers)
      }
      info(s"Auto generated Id $autoGeneratedSteamGameId")
      assert(autoGeneratedSteamGameId.isValidLong)

    }

    Scenario("A client sends a request to retrieve game information") {
      Given("A valid game Id and a GET request")
      implicit val timeout = RouteTestTimeout(20.seconds.dilated)
      val x = Random.alphanumeric
      val gameName = s"game_${(x take 20).mkString}"
      val game = generateGameRequest(gameName)

      val autoGeneratedSteamGameId = Post("/games").withEntity(ContentTypes.`application/json`, game) ~!> routes ~> check {
        assert(status == StatusCodes.Created)
        processHeaderId(headers)
      }
      info(s"Auto generated Id $autoGeneratedSteamGameId")
      assert(autoGeneratedSteamGameId.isValidLong)


      When("Get request is sent")
      Get(s"/games/$autoGeneratedSteamGameId").withEntity(ContentTypes.`application/json`, game) ~!> routes ~> check {
        Then("The game information should be returned")
        assert(status == StatusCodes.OK)
        assert(entityAs[GameState] == GameState(autoGeneratedSteamGameId,gameName))
      }
    }

    Scenario("A client sends a request to delete a game") {
      Given("A valid game Id and a DELETE request")
      implicit val timeout = RouteTestTimeout(20.seconds.dilated)

      val game = generateGameRequest()
      val autoGeneratedSteamGameId = Post("/games").withEntity(ContentTypes.`application/json`, game) ~!> routes ~> check {
        assert(status == StatusCodes.Created)
        processHeaderId(headers)
      }
      info(s"Auto generated Id $autoGeneratedSteamGameId")
      assert(autoGeneratedSteamGameId.isValidLong)


      When("Delete request is sent")
      Delete(s"/games/$autoGeneratedSteamGameId").withEntity(ContentTypes.`application/json`, game) ~!> routes ~> check {
        Then("The game information should be returned")
        assert(status == StatusCodes.OK)
        assert(entityAs[ResponseWithMessage] == ResponseWithMessage(200, Some("Game was deleted successfully.")) )
      }
    }

    //TODO: Failed Test , deadletters due to futures used inside actor instead of pipeTo
//    ignore("Failed Test due to use of Futures/Ask Pattern inside Receive Method.") {
      Scenario("Update a Game Name for a given SteamAppId") {
        implicit val timeout = RouteTestTimeout(10.seconds.dilated)
        Given("a valid SteamAppId and new game name")
        val x = Random.alphanumeric
        val gameName = s"game_${(x take 20).mkString}"
        val game =
          s"""
             |{
             |    "steamAppName": "$gameName"
             |}
             |""".stripMargin

        val autoGeneratedSteamGameId = Post("/games").withEntity(ContentTypes.`application/json`, game) ~!> routes ~> check {
          assert(status == StatusCodes.Created)
          processHeaderId(headers)
        }
        info(s"Auto generated Id $autoGeneratedSteamGameId")
        assert(autoGeneratedSteamGameId.isValidLong)
        val y = Random.alphanumeric
        val updatedName = s"game_${(y take 20).mkString}"
        val gameUpdateRequest =
          s"""
             |{
             |    "steamAppName": "$updatedName"
             |}
             |""".stripMargin

        When("UpdateGameRequest is sent")
        Patch(s"/games/$autoGeneratedSteamGameId")
          .withEntity(ContentTypes.`application/json`, gameUpdateRequest) ~!> routes ~> check {
          //        Then("The updated game information should be returned")
          //        assert(status == StatusCodes.OK)
          //        assert(entityAs[GameState] == GameState(autoGeneratedSteamGameId, updatedName))
        }

      }
//    }

    //TODO: Failed Test Sequence to violate business rule of no duplicate SteamAppName
//    ignore("Duplicate will cause failure") {
      Scenario("SteamAppName should not have duplicates") {
        implicit val timeout = RouteTestTimeout(10.seconds.dilated)
        Given("Given Two valid Games")
        val game = generateGameRequest("game1")
        val game2 = generateGameRequest("game2")
        val autoGeneratedSteamGameId = Post("/games").withEntity(ContentTypes.`application/json`, game) ~!> routes ~> check {
          assert(status == StatusCodes.Created)
          processHeaderId(headers)
        }
        val autoGeneratedSteamGameId2 = Post("/games").withEntity(ContentTypes.`application/json`, game2) ~!> routes ~> check {
          assert(status == StatusCodes.Created)
          processHeaderId(headers)
        }

        val gameUpdateRequest = generateGameRequest("game1")

        When("UpdateGameRequest is sent to update Game2")
        Patch(s"/games/$autoGeneratedSteamGameId2").withEntity(ContentTypes.`application/json`, gameUpdateRequest) ~!> routes

        When("Get request is sent")
        val gameState2Get = Get(s"/games/$autoGeneratedSteamGameId").withEntity(ContentTypes.`application/json`, game) ~!> routes ~> check {
          Then("The game information should be returned")
          assert(status == StatusCodes.OK)
          entityAs[GameState]
        }
        info(gameState2Get.toString)

      }
//    }
  }
}

