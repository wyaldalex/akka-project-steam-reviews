package dev.galre.josue.steamreviews
package controller

import akka.actor.ActorRef
import akka.http.scaladsl.model.{ ContentTypes, StatusCodes }
import akka.http.scaladsl.server.Route
import akka.http.scaladsl.testkit.RouteTestTimeout
import akka.testkit.TestDuration
import akka.util.Timeout
import dev.galre.josue.steamreviews.repository.GameManagerActor
import dev.galre.josue.steamreviews.repository.entity.GameActor.GameState
import dev.galre.josue.steamreviews.service.utils.Actors
import dev.galre.josue.steamreviews.service.utils.Actors.StateManagers
import dev.galre.josue.steamreviews.spec.RoutesSpec

import scala.util.Random
import scala.concurrent.duration._
import scala.concurrent.ExecutionContext

//Used to desiralize the entities
import de.heikoseeberger.akkahttpcirce.FailFastCirceSupport._
import io.circe.generic.auto._

class GameRouterTest extends RoutesSpec {

  Feature("A GameRouter Behavior") {

    val x = Random.alphanumeric
    implicit val timeout = Timeout(10.seconds)
//    val gameManagerActor: ActorRef = system.actorOf(GameManagerActor.props)
//    val stateManagers: StateManagers = StateManagers(
//      gameManagerActor, gameManagerActor, ActorRef.noSender,
//      ActorRef.noSender, ActorRef.noSender, ActorRef.noSender, ActorRef.noSender
//    )
    implicit def executionContext: ExecutionContext = system.dispatcher
    val stateManagers: StateManagers = Actors.init

    val routes: Route = GameRouter(stateManagers.Command.game, stateManagers.Query.game).routes

    //TODO: Error due to the use of futures inside the GameManageActor instead of pipeTo
    Scenario("A client send a request to create a new game") {

      implicit val timeout = RouteTestTimeout(10.seconds.dilated)
      Given("a valid Game Information and a POST request")
      val x = Random.alphanumeric
      val gameName = s"game_${(x take 20).mkString}"
      val game =
        s"""
          |{
          |    "steamAppName": "$gameName"
          |}
          |""".stripMargin

      When("a request to create a new game is sent to the server")
      val autoGeneratedSteamGameId = Post("/games").withEntity(ContentTypes.`application/json`, game) ~!> routes ~> check {
        Then("will create a new game and will respond with the game id and a 201 created status")
        assert(status == StatusCodes.Created)
        val autoGeneratedId = headers.head.value().substring(17).
          replaceAll("Some", "")
          .replaceAll("\\)", "")
          .replaceAll("\\(", "")
        autoGeneratedId.split(",")(0).toLong
      }
      info(s"Auto generated Id $autoGeneratedSteamGameId")
      assert(autoGeneratedSteamGameId.isValidLong)

    }

    Scenario("A client sends a request to retrieve game information") {
      Given("A valid game Id and a GET request")
      implicit val timeout = RouteTestTimeout(20.seconds.dilated)
      val x = Random.alphanumeric
      val gameName = s"game_${(x take 20).mkString}"
      val game =
        s"""
           |{
           |    "steamAppName": "$gameName"
           |}
           |""".stripMargin

      val autoGeneratedSteamGameId = Post("/games").withEntity(ContentTypes.`application/json`, game) ~!> routes ~> check {
        assert(status == StatusCodes.Created)
        val autoGeneratedId = headers.head.value().substring(17).
          replaceAll("Some", "")
          .replaceAll("\\)", "")
          .replaceAll("\\(", "")
        autoGeneratedId.split(",")(0).toLong
      }
      info(s"Auto generated Id $autoGeneratedSteamGameId")
      assert(autoGeneratedSteamGameId.isValidLong)


      When("Get request is sent")
      Get(s"/games/$autoGeneratedSteamGameId").withEntity(ContentTypes.`application/json`, game) ~!> routes ~> check {
        Then("The game information should be returned")
        assert(status == StatusCodes.OK)
        assert(entityAs[GameState] == GameState(autoGeneratedSteamGameId,gameName))
      }
    }

    //TODO: Failed test, deadletters due to futures used inside actor instead of pipeTo
//    Scenario("Update a Game Name for a given SteamAppId") {
//      implicit val timeout = RouteTestTimeout(10.seconds.dilated)
//      Given("a valid SteamAppId and new game name")
//      val x = Random.alphanumeric
//      val gameName = s"game_${(x take 20).mkString}"
//      val game =
//        s"""
//           |{
//           |    "steamAppName": "$gameName"
//           |}
//           |""".stripMargin
//
//      val autoGeneratedSteamGameId = Post("/games").withEntity(ContentTypes.`application/json`, game) ~!> routes ~> check {
//        assert(status == StatusCodes.Created)
//        val autoGeneratedId = headers.head.value().substring(17).
//          replaceAll("Some", "")
//          .replaceAll("\\)", "")
//          .replaceAll("\\(", "")
//        autoGeneratedId.split(",")(0).toLong
//      }
//      info(s"Auto generated Id $autoGeneratedSteamGameId")
//      assert(autoGeneratedSteamGameId.isValidLong)
//      val y = Random.alphanumeric
//      val updatedName = s"game_${(y take 20).mkString}"
//      val gameUpdateRequest =
//        s"""
//           |{
//           |    "steamAppName": "$updatedName"
//           |}
//           |""".stripMargin
//
//      When("UpdateGameRequest is sent")
//      Patch(s"/games/$autoGeneratedSteamGameId").withEntity(ContentTypes.`application/json`, gameUpdateRequest) ~!> routes ~> check {
////        Then("The updated game information should be returned")
////        assert(status == StatusCodes.OK)
////        assert(entityAs[GameState] == GameState(autoGeneratedSteamGameId, updatedName))
//      }
//
//    }

  }
}

